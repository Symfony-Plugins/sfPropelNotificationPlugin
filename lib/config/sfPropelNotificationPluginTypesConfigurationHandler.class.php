<?php
/*
 * This file is part of the sfPropelNotificationPlugin package.
 * 
 * (c) 2006-2007 Tristan Rivoallan <tristan@rivoallan.net>
 * 
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Configuration handler for plugin's types.yml config file.
 * 
 * @package     sfPropelNotificationPlugin
 * @subpackage  config
 * @author      Tristan Rivoallan <tristan@rivoallan.net>
 * 
 * @see         http://www.symfony-project.com/book/trunk/19-Mastering-Symfony-s-Configuration-Files
 */
class sfPropelNotificationPluginTypesConfigurationHandler extends sfYamlConfigHandler
{
  /**
   * Executes this configuration handler.
   *
   * @param array An array of absolute filesystem path to a configuration file.
   *
   * @return string Data to be written to a cache file.
   *
   * @throws sfConfigurationException  If a requested configuration file does not exist or is not readable.
   * @throws sfParseException          If a requested configuration file is improperly formatted.
   */
  public function execute($configFiles)
  {

    // parse the yaml
    $raw_config_array = $this->parseYamls($configFiles);

    // Parse configuration
    $compiled_configuration = array();

    // -- Data sources
    foreach ($raw_config_array as $type_name => $type_spec)
    {
      // Only process enabled datasources
      if (isset($type_spec['enabled']) && $type_spec['enabled'] === true)
      {
        $this->parseType($type_name, $type_spec);
        $compiled_configuration[$type_name] = $type_spec;
      }
    }

    // compile data
    $retval = sprintf("<?php\n".
                      "// auto-generated by %s\n".
                      "// date: %s\nsfConfig::set('sfPropelNotificationPlugin_types', \n%s\n);\n?>",
                      __CLASS__, date('Y/m/d H:i:s'), var_export($compiled_configuration, true));

    return $retval;
  }
  
  private function parseType($name, $spec)
  {
    if (!isset($spec['logic_class']))
    {
      $msg = sprintf('sfPropelNotificationPlugin/types.yml : The "logic_class" parameter is mandatory');
      throw new sfParseException($msg);
    }
    
    if (!class_exists($spec['logic_class']))
    {
      $msg = sprintf('sfPropelNotificationPlugin/types.yml : Notification logic class "%s" does not exist', $spec['logic_class']);
      throw new sfParseException($msg);
    }
    
    if (!is_callable(array($spec['logic_class'], sfInflector::camelize($name))))
    {
      $msg = sprintf('sfPropelNotificationPlugin/types.yml : "%s::%s" must be callable', $spec['logic_class'], sfInflector::camelize($name));
      throw new sfParseException($msg);
    }   
  }
}
